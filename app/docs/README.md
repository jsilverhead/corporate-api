# TEMPLATE API

Этот документ описывает, как работать с API сервиса TEMPLATE. Пожалуйста, сообщайте о всех неточностях, ошибках и опечатках через таск-трекер.

## Концепция дизайна API

Дизайн API представляет собой что-то похожее на RPC и JSON-RPC, обычно это называют RPC-like API. Только в отличие от классических RPC, где есть только один эндпоинт, а метод передается в теле запроса, дизайн данного API подразумевает разные эндпоинты под каждое действие. Эндпоинты в данном случае правильнее называть _методами_. Думайте о методах как о функциях, которые можно вызывать. Каждый метод принимает какой-то набор аргументов.

Методы можно условно разделить на 2 типа:

- `GET` — это идемпотентные методы — методы чтения и поиска — они никак не изменяют данные, хранимые на бекенде. Они принимают аргументы в виде query-строки.
- `POST` — это не идемпотентные методы и методы, которые что-то редактируют на бекенде. Если метод что-то создает, редактирует, удаляет, генерирует и т.п., то это всегда `POST`. Они принимают аргументы в виде тела запроса в формате `application/json`.

Методы `PUT`, `PATCH` и `DELETE` в API не используются.

В ответах методов используется лишь 3 статус кода:

- `200` — это статус успешно выполненного запроса.
- `400` — это статус запроса, завершенного с ошибкой из-за неверных действий клиента.
- `500` — это статус запроса, завершенного с ошибкой из-за проблем на стороне API.

## Пагинация

Пагинация в API представлена в виде двух параметров: `pagination[offset]` и `pagination[count]`. В методах API, которые поддерживают пагинацию, данные параметры являются обязательными. Первый параметр отвечает за то, сколько ресурсов нужно пропустить, а второй отвечает за то, сколько ресурсов нужно получить.

Как получить 15 первых ресурсов:

```http
/exampleListMethod?pagination[offset]=0&pagination[count]=15
```

Если необходимо реализовать пагинацию, то срез ресурсов для **второй** страницы можно получить так (пропускаем первые 15 ресурсов и получаем следующие 15):

```http
/exampleListMethod?pagination[offset]=15&pagination[count]=15
```

## Работа с ошибками

API возвращает ошибки в формате [Problem Details for HTTP APIs (RFC 7807)](https://tools.ietf.org/html/rfc7807).

Для проверки запроса на успешность клиентское приложение должно проверить содержимое заголовка `Content-Type`: если заголовок присутствует и его значение равно `application/problem+json`, значит запрос завершился с ошибкой, в любом ином случае запрос считается успешным. Чтобы идентифицировать ошибку, клиентское приложение должно распарсить JSON, вернувшийся в ответ, и идентифицировать ошибку по полю `type`. **Клиент не должен идентифицировать ошибку по статус-коду ответа**, различные статус-коды используются в API исключительно из семантических соображений, использование статус-кодов для реализации какой-либо внутренней логики клиентских приложений не предполагается.

### Ошибки валидации

Любой метод, в который можно передать данные через JSON body или query string, может вернуть ошибку валидации (с типом `validation_error`). Такая ошибка от обычной отличается тем, что в теле ответа возвращается дополнительное поле `violations` с массивом ошибок.

Каждый элемент массива обязательно содержит поле `type` с идентификатором типа ошибки, поле `pointer` с указателем на проблемное поле в формате [JSON pointer](https://tools.ietf.org/html/rfc6901), поле `description` с понятным описанием ошибки для разработчика (это поле не для пользователей вашего приложения!), а также дополнительные поля, которые могут разниться от типа ошибки валидации.

Клиентское приложение само должно решать, какие ошибки отображать, а какие нет, какие ошибки являются ошибкой пользователя, а какие — ошибкой разработчика приложения. Например, если пользователь ввел номер телефона, который уже кем-то занят, то это пользовательская ошибка и ее можно отобразить в интерфейсе, а если пользователь отправил телефон в неправильном формате несмотря на наличие маски или функционала валидации на стороне клиента, то это можно считать ошибкой приложения — нет смысла показывать эту ошибку пользователю, если приложение работает не так, как задумано, подобную ошибку нужно куда-нибудь залогировать и исправить.
